#pragma once

#include <array>
#include <span>

#include "peripherals/lpc40xx/pin.hpp"
#include "inactive.hpp"
#include "module.hpp"
#include "utility/error_handling.hpp"
#include "utility/math/units.hpp"

namespace sjsu
{
/// Generic settings for a standard SPI peripheral
struct SpiSettings_t : public MemoryEqualOperator_t<SpiSettings_t>
{
  /// SPI Data Frame bitwidths
  enum class FrameSize : uint8_t
  {
    kFourBits = 0,  // The smallest standard frame sized allowed for SJSU-Dev2
    kFiveBits,
    kSixBits,
    kSevenBits,
    kEightBits,
    kNineBits,
    kTenBits,
    kElevenBits,
    kTwelveBits,
    kThirteenBits,
    kFourteenBits,
    kFifteenBits,
    kSixteenBits,  // The largest standard frame sized allowed for SJSU-Dev2
  };

  /// Determins the polarity of the SPI clock
  enum class Polarity : uint8_t
  {
    // Start the clock LOW then each cycle consists of a pulse of HIGH
    kIdleLow = 0,

    // Start the clock HIGH then each cycle consists of a pulse of LOW
    kIdleHigh,
  };

  /// Determins the phase of the SPI clock
  enum class Phase : uint8_t
  {
    // Data is valid on the LEADING edge of SPI clock
    kSampleLeading = 0,

    // Data is valid on the TRAILING edge of SPI clock
    kSampleTrailing,
  };

  /// Serial clock frequency
  units::frequency::hertz_t clock_rate = 100_kHz;
  /// The number of bits of each SPI transaction
  FrameSize frame_size = FrameSize::kEightBits;
  /// The polarity of the pins when the signal is idle
  Polarity polarity = Polarity::kIdleLow;
  /// The phase of the clock signal when communicating
  Phase phase = Phase::kSampleLeading;
};

/// An abstract interface for hardware that implements the Serial Peripheral
/// Interface (SPI) communication protocol.
/// @ingroup l1_peripheral
class Spi : public Module<SpiSettings_t>
{
 public:
  /// Write 8-bit data to the SPI bus and read back the data response on the
  /// bus.
  ///
  /// @param buffer - buffer of data to write to the spi bus. The contents of
  /// the buffer will be modified to the results of the response.
  virtual void Transfer(std::span<uint8_t> buffer) = 0;

  /// Write 16-bit data to the SPI bus and read back the data response on the
  /// bus.
  ///
  /// @param buffer - buffer of data to write to the spi bus. The contents of
  /// the buffer will be modified to the results of the response.
  virtual void Transfer(std::span<uint16_t> buffer) = 0;

  // ===========================================================================
  // Helper Functions
  // ===========================================================================

  /// Transfer a single byte
  ///
  /// @param data - byte to send
  /// @return uint8_t - byte read back from bus
  uint8_t Transfer(uint8_t data)
  {
    std::array<uint8_t, 1> buffer = { data };
    Transfer(buffer);
    return buffer[0];
  }

  /// Transfer a 16-bit int
  ///
  /// @param data - 16-bit int to send
  /// @return uint16_t - byte read back from bus
  uint16_t Transfer(uint16_t data)
  {
    std::array<uint16_t, 1> buffer = { data };
    Transfer(buffer);
    return buffer[0];
  }

  /// Transfer a const array of data and receive an array back.
  /// This function should be used only in cases where the array to be
  /// transferred is const. This method must perform a copy of the data into a
  /// mutable array before performing the transfer. This is typically optimized
  /// away if the output of the method is not stored in a variable.
  ///
  /// Usage:
  ///
  ///    const std::array<uint8_t, 4> to_device = {1, 2, 3, 4};
  ///    auto from_device = spi.ConstTransfer(data);
  ///
  /// @tparam T - deduced data type of the array. Must be less than or equal to
  ///             uint16_t.
  /// @tparam length - deduced length of the array.
  ///
  /// @param data - the array to be sent via SPI.
  /// @return std::array<T, length> - the results of the tranfer. The result can
  ///         be ignored with little cost to the program. C++20 performs copy
  ///         ellision, preventing a memcpy from occuring when the result is
  ///         returned.
  template <typename T, size_t length>
  std::array<T, length> ConstTransfer(const std::array<T, length> & data)
  {
    // Compile time check that the datatype used is equal to or smaller than
    // datatype for Transfer. This will produce a better error message than the
    // generic template error message generated by the compiler.
    static_assert(sizeof(T) <= sizeof(uint16_t),
                  "Array datatype must be uint16_t or smaller.");

    // Create a mutable buffer with a copy of the const array data.
    std::array<T, length> buffer = data;

    // Transfer the data
    Transfer(buffer);

    // Return the data read back from the bus.
    return buffer;
  }
};

/// Template specialization that generates an inactive sjsu::Spi.
template <>
inline sjsu::Spi & GetInactive<sjsu::Spi>()
{
  class InactiveSpi : public sjsu::Spi
  {
   public:
    void ModuleInitialize() override {}
    void Transfer(std::span<uint8_t>) override {}
    void Transfer(std::span<uint16_t>) override {}
  };

  static InactiveSpi inactive;
  return inactive;
}
}  // namespace sjsu
